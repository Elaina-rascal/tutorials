## 面相对象编程思想
### 结构体:存储不同类型的数据项
例程电机代码:
```cpp
Motor1SetRPM(float rpm)
{
    float scale=2;
    int CCR=rpm*scale;
    __HAL_SetCompare(&htim2,TIM_CHANNEL_1,CCR);
}
Motor2SetRPM(float rpm)
{
    float scale=2;
    int CCR=rpm*scale;
    __HAL_SetCompare(&htim1,TIM_CHANNEL_2,CCR);
}
//下略电机3,4
```
#### 上述代码的特点
- 1.可维护性差,如果每个电机都有四个函数,需要写16个
- 2.大部分代码是通用的,只有小部分地方不一样(对于四个同型号电机基本只有引脚不一样)
#### 优化的方向
- 把变量放到数组里
```cpp
TIM_HandleType* MotorTIM[4];
TIM_ChannelType MotorChannel[4];

MotorSetRPM(int id,float rpm)
{
    float scale=2;
    int CCR=rpm*scale;
    __HAL_SetCompare(MotorTIM[id],MotorChannel[id],CCR);
}
```
- 上述代码再增加一个新的电机需要把所有列表长度加一
- 很容易发生**数组越界**导致程序**起飞**
---
- 再优化一下放到结构体里面
```cpp
struct Motor
{
    TIM_HandleType* _motorTIM;
    TIM_ChannelType _motorChannel;
    float TargetRPM;
};
Motor MotorList[4];
MotorList[0]._motorTIM= &htim1;
MotorList[0]._motorChannel=TIM_Channel_1;
//下略1-3的初始化
MotorSetRPM(Motor* motor,float rpm)
{
    float scale=2;
    int CCR=rpm*scale;
    motor->TargetRPM=rpm;
    __HAL_SetCompare(motor->_motorTIM,motor->_motorChannel,CCR);
}

// 调用例程
MotorSetRPM(&MotorList[0],50);
```
#### 上述代码的注意点:
##### 1.MotorSetRPM(`Motor* `motor,float rpm)这里用的是指针而不是对应的变量类型
- 用对应变量类型而不是指针会把你的结构体复制一份,导致你对他的赋值不会生效 motor->TargetRPM=rpm;
##### 2.上面的`结构体+传入结构体地址代码`就像c++的类,声明的数组叫做实例
##### 3.有可能会忘记初始化
## 在C++中的实现
```cpp
class Motor
{
    public:
        //构造函数
        Motor(TIM_HandleType* motorTIM,TIM_ChannelType motorChannel)
        {
            _motorTIM=motorTIM;
            _motorChannel=motorChannel
        }
        SetRPM(float rpm);
        float TargetRPM;
    private:
        TIM_HandleType* _motorTIM;
       
        TIM_ChannelType _motorChannel;
};
Motor::SetRPM(float rpm)
{
    float scale=2;
    int CCR=rpm*scale;
    TargetRPM=rpm;
    __HAL_SetCompare(_motorTIM,_motorChannel,CCR);
}
//与下面的代码完全等效
Motor::SetRPM(Motor* this,float rpm)
{
    float scale=2;
    int CCR=rpm*scale;
    this->TargetRPM=rpm;
    __HAL_SetCompare(this->_motorTIM,this->_motorChannel,CCR);
}

Motor1 =Motor(&htim1,_motorChannel)
Motor1.SetRPM(50); //等效于上面C语言的MotorSetRPM(&MotorList[0],50);


```
- c++的类内函数就是隐藏了this指针的传入结构体的函数
- C的调用是函数一样,传入实例调用。C++则是直接通过实例调用函数
- c++的类多构造函数,在定义实例的时候就初始化
### 面向对象的总结
- 在有多个实例的时候必用。
- 在只有单个实例的时候可以把变量塞到自己定义里面,不用全局变量乱拉。
### 类的继承
- 语法示例:
``` cpp
class MotorEnhance: public Motor
{
    //会包含Motor中public的部分与private部分
    //但是Motor中的private不可访问
};
```
### 函数模版
- 语法示例
```cpp
this->create_publisher<std_msgs::msg::String>("topic", 10);
```
- <>中包裹的是数据类型定义
## c++ 的编译过程+CMake
### 1.预处理
- 处理所有#开头的指令（`#include`、`#define`等）
- 展开头文件、替换宏定义、删除注释
- 生成.i文件 
> 对应cmake find_package+target_include
### 2.编译
- 将 C++ 代码转换为汇编语言
- 生成.s文件
### 3.汇编
- 将汇编语言转换为机器码（二进制指令）
- 生成.o（Linux）或.obj（Windows）目标文件
### 4.链接
- 将多个目标文件和所需的库文件合并
- 解析外部符号引用（函数调用、全局变量等）
- 生成最终可执行文件
> 对应cmake 的target_link_libraries
## 面相对象编程思想
### 结构体:存储不同类型的数据项
例程电机代码:
```cpp
Motor1SetRPM(float rpm)
{
    float scale=2;
    int CCR=rpm*scale;
    __HAL_SetCompare(&htim2,TIM_CHANNEL_1,CCR);
}
Motor2SetRPM(float rpm)
{
    float scale=2;
    int CCR=rpm*scale;
    __HAL_SetCompare(&htim1,TIM_CHANNEL_2,CCR);
}
//下略电机3,4
```
#### 上述代码的特点
- 1.可维护性差,如果每个电机都有四个函数,需要写16个
- 2.大部分代码是通用的,只有小部分地方不一样(对于四个同型号电机基本只有引脚不一样)
#### 优化的方向
- 把变量放到数组里
```cpp
TIM_HandleType* MotorTIM[4];
TIM_ChannelType MotorChannel[4];

MotorSetRPM(int id,float rpm)
{
    float scale=2;
    int CCR=rpm*scale;
    __HAL_SetCompare(MotorTIM[id],MotorChannel[id],CCR);
}
```
- 上述代码再增加一个新的电机需要把所有列表长度加一
- 很容易发生**数组越界**导致程序**起飞**
---
- 再优化一下放到结构体里面
```cpp
struct Motor
{
    TIM_HandleType* _motorTIM;
    TIM_ChannelType _motorChannel;
    float TargetRPM;
};
Motor MotorList[4];
MotorList[0]._motorTIM= &htim1;
MotorList[0]._motorChannel=TIM_Channel_1;
//下略1-3的初始化
MotorSetRPM(Motor* motor,float rpm)
{
    float scale=2;
    int CCR=rpm*scale;
    motor->TargetRPM=rpm;
    __HAL_SetCompare(motor->_motorTIM,motor->_motorChannel,CCR);
}

// 调用例程
MotorSetRPM(&MotorList[0],50);
```
#### 上述代码的注意点:
##### 1.MotorSetRPM(`Motor* `motor,float rpm)这里用的是指针而不是对应的变量类型
- 用对应变量类型而不是指针会把你的结构体复制一份,导致你对他的赋值不会生效 motor->TargetRPM=rpm;
##### 2.上面的`结构体+传入结构体地址代码`就像c++的类,声明的数组叫做实例
##### 3.有可能会忘记初始化
## 在C++中的实现
```cpp
class Motor
{
    public:
        //构造函数
        Motor(TIM_HandleType* motorTIM,TIM_ChannelType motorChannel)
        {
            _motorTIM=motorTIM;
            _motorChannel=motorChannel
        }
        SetRPM(float rpm);
        float TargetRPM;
    private:
        TIM_HandleType* _motorTIM;
       
        TIM_ChannelType _motorChannel;
};
Motor::SetRPM(float rpm)
{
    float scale=2;
    int CCR=rpm*scale;
    TargetRPM=rpm;
    __HAL_SetCompare(_motorTIM,_motorChannel,CCR);
}
//与下面的代码完全等效
Motor::SetRPM(Motor* this,float rpm)
{
    float scale=2;
    int CCR=rpm*scale;
    this->TargetRPM=rpm;
    __HAL_SetCompare(this->_motorTIM,this->_motorChannel,CCR);
}

Motor1 =Motor(&htim1,_motorChannel)
Motor1.SetRPM(50); //等效于上面C语言的MotorSetRPM(&MotorList[0],50);


```
- C++的类内函数就是隐藏了this指针的传入结构体的函数
- C的调用是函数一样,传入实例调用。C++则是直接通过实例调用函数
- C++的类多构造函数,在定义实例的时候就初始化
### 面向对象的总结
- 在有多个实例的时候必用。
- 在只有单个实例的时候可以把变量塞到自己定义里面,不用全局变量乱拉。
> ros 底层的有些库只有c++依赖,逻辑节点建议用python
### 类的继承
- 语法示例:
``` cpp
class MotorEnhance: public Motor
{
    //会包含Motor中public的部分与private部分
    //但是Motor中的private不可访问
};
```
### 函数模版
- 语法示例
```cpp
this->create_publisher<std_msgs::msg::String>("topic", 10);
```
- <>中包裹的是数据类型定义
## c++ 的编译过程+CMake
### 1.预处理
- 处理所有#开头的指令（`#include`、`#define`等）
- 展开头文件、替换宏定义、删除注释
- 生成.i文件 
> 对应cmake find_package+target_include
### 2.编译
- 将 C++ 代码转换为汇编语言
- 生成.s文件
### 3.汇编
- 将汇编语言转换为机器码（二进制指令）
- 生成.o（Linux）或.obj（Windows）目标文件
### 4.链接
- 将多个目标文件和所需的库文件合并
- 解析外部符号引用（函数调用、全局变量等）
- 生成最终可执行文件
> 对应cmake 的target_link_libraries
### cmake流程
- 配置工具链,c++版本,是否使用调试
- `find_package`寻找依赖包
- `add_executable`创建可执行文件与添加cpp源文件
- `target_include_directories`添加include .h文件的地址
- `target_link_libraries` 添加依赖库
```cmake
# 最低CMake版本要求
cmake_minimum_required(VERSION 3.10)

# 项目名称
project(SimpleProject)

# 设置C++标准
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 添加可执行文件，指定源文件
add_executable(myapp src/main.cpp)

# 指定头文件搜索路径
target_include_directories(myapp
    ${PROJECT_SOURCE_DIR}/include
)

# 链接系统库（这里以数学库m为例）
target_link_libraries(myapp
    math  # 系统数学库
)

```
## ROS2 CMake指令
### 1.install
```cmake
install(
  DIRECTORY launch config   #打包launch与配置文件
  DESTINATION share/${PROJECT_NAME}  
)
```
### 2. ament_target_dependencies
```cmake
ament_target_dependencies(my_node
  rclcpp
  sensor_msgs
)
```
- 类似cmake `target_link_libraries`
- 适合链接ros2的官方包
### 3.自动找包
```cmake
find_package(ament_cmake_auto REQUIRED) #先要有这一行
ament_auto_find_build_dependencies()
```
- 在package.xml中添加依赖,cmake中即可自动查找
### 4.自动链接
```cmake
ament_auto_add_library()
ament_auto_add_executable()
# 等效于下面的代码
add_executable()
target_include_directories()
target_link_libraries()
```

- 自动并不能处理所有情况尤其是`非ros包`

```cmake
cmake_minimum_required(VERSION 3.8)
project(pcl_handle)
set(CMAKE_C_COMPILER "clang")
set(CMAKE_CXX_COMPILER "clang++")


set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)


# find dependencies
find_package(ament_cmake_auto REQUIRED)
find_package(PCL 1.12.1 REQUIRED)
ament_auto_find_build_dependencies()
set(PclHandle "PclHandle")
set(PclIcp "PclIcp")
set(common_lib "common_lib")
file(GLOB PclCommonSrc "src/pcl_common/*.cpp")

ament_auto_add_library(${common_lib} SHARED ${PclCommonSrc})
ament_auto_add_library(${PclHandle} SHARED src/pcl_handle.cpp)
ament_auto_add_library(${PclIcp} SHARED src/pcl_icp.cpp)
target_include_directories(${common_lib} PUBLIC include/3rd_packages include/pcl_common)
target_link_directories(${PclHandle} PRIVATE ${common_lib})
target_link_directories(${PclIcp} PRIVATE ${common_lib})

rclcpp_components_register_node(${PclHandle}
  PLUGIN "PclHandle"
  EXECUTABLE ${PclHandle}_node
)
rclcpp_components_register_node(${PclIcp}
  PLUGIN "PclIcp"
  EXECUTABLE ${PclIcp}_node
)

# target_precompile_headers(${PclHandle} PRIVATE include/pch.hpp)

# 需要分开安装
install(DIRECTORY launch config
  DESTINATION share/${PROJECT_NAME}
)
ament_auto_package()
```